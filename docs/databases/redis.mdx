---
title: Redis
description: "Using OmniQL with Redis"
---

Redis is an in-memory data store used for caching, sessions, and real-time applications.

## Quick Start
```go
import (
    "github.com/redis/go-redis/v9"
    "github.com/omniql-engine/omniql"
)

// Your Redis connection
rdb := redis.NewClient(&redis.Options{
    Addr: "localhost:6379",
})

// Wrap with OmniQL
client := oql.WrapRedis(rdb, "tenant_1")

// Query with OmniQL syntax
user, _ := client.Query(":GET User WHERE id = 42")
```

## How Redis Works

Redis is **key-value**, not relational. It cannot filter data natively like SQL databases.

| Database | WHERE Filtering |
|----------|-----------------|
| PostgreSQL | Native (database does it) |
| MySQL | Native (database does it) |
| MongoDB | Native (database does it) |
| Redis | OmniQL handles it in Go |

OmniQL bridges this gap by providing filtering logic that works seamlessly with your queries.

## Data Model

OmniQL maps entities to Redis Hash structures:

| Concept | OmniQL | Redis |
|---------|--------|-------|
| Entity | `User` | Hash keys with prefix |
| Record | `User WHERE id = 1` | `HGETALL tenant:user:1` |
| Field | `name`, `email` | Hash fields |

### Key Pattern
```
{tenant}:{entity}:{id}
```

Examples:
```
tenant_1:user:1          ‚Üí User with id 1
tenant_1:user:2          ‚Üí User with id 2
tenant_1:order:1001      ‚Üí Order with id 1001
```

## Query Types

### Direct Key Lookup (Fast)

When you query by `id`, OmniQL translates directly to Redis commands:
```go
// OmniQL
user, _ := client.Query(":GET User WHERE id = 42")

// Internally executes:
// HGETALL tenant_1:user:42
```

This is **instant** - same performance as native Redis.

### Filtered Query (Scan + Filter)

When you query by other fields, OmniQL scans keys and filters results:
```go
// OmniQL
users, _ := client.Query(":GET User WHERE age > 21 AND status = \"active\" LIMIT 10")

// Internally:
// 1. SCAN tenant_1:user:*
// 2. HGETALL each key
// 3. Filter using MatchesConditions()
// 4. Return matching results up to LIMIT
```

This works but scans data - use for smaller datasets or with LIMIT.

## CRUD Operations

### GET (HGETALL)

**By ID (direct lookup):**
```go
user, _ := client.Query(":GET User WHERE id = 1")
// ‚Üí HGETALL tenant_1:user:1
```

**With filtering:**
```go
users, _ := client.Query(":GET User WHERE status = \"active\" LIMIT 10")
// ‚Üí SCAN + HGETALL + filter
```

**All records:**
```go
users, _ := client.Query(":GET User")
// ‚Üí SCAN tenant_1:user:* + HGETALL each
```

### CREATE (HMSET)
```go
result, _ := client.Query(`:CREATE User WITH name:"John", email:"john@example.com", age:30`)
// ‚Üí HMSET tenant_1:user:{generated_id} name "John" email "john@example.com" age "30"

// result = []map[string]any{{"inserted_id": "uuid-here", "rows_affected": 1}}
```

### UPDATE (HSET)
```go
result, _ := client.Query(`:UPDATE User SET status:"active" WHERE id = 1`)
// ‚Üí HSET tenant_1:user:1 status "active"

// result = []map[string]any{{"rows_affected": 1}}
```

### DELETE (DEL)
```go
result, _ := client.Query(`:DELETE User WHERE id = 1`)
// ‚Üí DEL tenant_1:user:1

// result = []map[string]any{{"rows_affected": 1}}
```

### BULK INSERT
```go
result, _ := client.Query(`:BULK INSERT User WITH [name:"Alice", age:28], [name:"Bob", age:32]`)
// ‚Üí HMSET tenant_1:user:1 name "Alice" age "28"
// ‚Üí HMSET tenant_1:user:2 name "Bob" age "32"
```

### UPSERT
```go
result, _ := client.Query(`:UPSERT User WITH id:1, name:"John" ON id`)
// ‚Üí HMSET tenant_1:user:1 name "John"
```

### DROP TABLE
```go
result, _ := client.Query(`:DROP TABLE User`)
// ‚Üí Deletes all keys matching tenant_1:user:*
```

## Filtering Support

OmniQL supports all standard operators for Redis filtering:

| Operator | Example | Supported |
|----------|---------|-----------|
| `=` | `status = "active"` | ‚úÖ |
| `!=` | `status != "banned"` | ‚úÖ |
| `>` | `age > 21` | ‚úÖ |
| `<` | `age < 65` | ‚úÖ |
| `>=` | `score >= 100` | ‚úÖ |
| `<=` | `price <= 50` | ‚úÖ |
| `IN` | `status IN ("active", "pending")` | ‚úÖ |
| `NOT IN` | `role NOT IN ("admin", "mod")` | ‚úÖ |
| `BETWEEN` | `age BETWEEN 18 AND 65` | ‚úÖ |
| `LIKE` | `name LIKE "John%"` | ‚úÖ |
| `IS NULL` | `deleted_at IS NULL` | ‚úÖ |
| `IS NOT NULL` | `email IS NOT NULL` | ‚úÖ |
| `AND` | `age > 21 AND active = true` | ‚úÖ |
| `OR` | `status = "active" OR role = "admin"` | ‚úÖ |

### Example with Complex Filter
```go
users, _ := client.Query(`
    :GET User 
    WHERE age > 21 
    AND status IN ("active", "pending") 
    AND email IS NOT NULL
    ORDER BY name ASC
    LIMIT 10
`)
```

## Aggregations

OmniQL provides aggregation operations:

### COUNT
```go
result, _ := client.Query(":COUNT User WHERE active = true")
// result = []map[string]any{{"count": 42}}
```

### SUM
```go
result, _ := client.Query(":SUM balance FROM Account")
// result = []map[string]any{{"sum": 15000.50}}
```

### AVG
```go
result, _ := client.Query(":AVG age FROM User")
// result = []map[string]any{{"avg": 28.5}}
```

### MIN / MAX
```go
result, _ := client.Query(":MIN price FROM Product")
// result = []map[string]any{{"min": 9.99}}

result, _ := client.Query(":MAX score FROM Player")
// result = []map[string]any{{"max": 99500}}
```

## Transactions

Redis supports transactions with MULTI/EXEC:
```go
client.Query(":BEGIN")
client.Query(`:UPDATE User SET login_count:5 WHERE id = 1`)
client.Query(`:UPDATE User SET last_login:"2025-01-15" WHERE id = 1`)
client.Query(":COMMIT")
```

Translates to:
```redis
MULTI
HSET tenant_1:user:1 login_count "5"
HSET tenant_1:user:1 last_login "2025-01-15"
EXEC
```

**Rollback:**
```go
client.Query(":BEGIN")
client.Query(`:UPDATE User SET status:"banned" WHERE id = 1`)
client.Query(":ROLLBACK")  // Cancels - nothing executed
```

> **Note:** `DISCARD` cancels the transaction before execution. Once `EXEC` runs, changes cannot be rolled back.

## Permissions (ACL)

Redis uses ACL for user management:

### CREATE USER
```go
client.Query(`:CREATE USER analyst WITH PASSWORD "secret123"`)
// ‚Üí ACL SETUSER analyst on >secret123
```

### GRANT
```go
client.Query(`:GRANT READ ON User TO analyst`)
// ‚Üí ACL SETUSER analyst +hgetall +get
```

### REVOKE
```go
client.Query(`:REVOKE WRITE ON User FROM analyst`)
// ‚Üí ACL SETUSER analyst -hset -hmset -del
```

### DROP USER
```go
client.Query(`:DROP USER analyst`)
// ‚Üí ACL DELUSER analyst
```

> **Note:** Redis has users with permissions, not roles. `CREATE ROLE`, `DROP ROLE`, `ASSIGN ROLE` are not supported.

## Type Storage

All Redis values are stored as strings:

| OmniQL Type | Redis Storage |
|-------------|---------------|
| `STRING` | String |
| `INT` | String ("42") |
| `BOOLEAN` | String ("true"/"false") |
| `TIMESTAMP` | String (ISO format) |
| `JSON` | String (serialized) |
| `UUID` | String |

OmniQL automatically converts types when filtering.

## Supported Operations

| Operation | Supported | Notes |
|-----------|-----------|-------|
| GET | ‚úÖ | HGETALL |
| CREATE | ‚úÖ | HMSET |
| UPDATE | ‚úÖ | HSET |
| DELETE | ‚úÖ | DEL |
| UPSERT | ‚úÖ | HMSET |
| BULK INSERT | ‚úÖ | Multiple HMSET |
| DROP TABLE | ‚úÖ | DEL pattern |
| COUNT | ‚úÖ | Via OmniQL |
| SUM / AVG / MIN / MAX | ‚úÖ | Via OmniQL |
| WHERE (all operators) | ‚úÖ | Via OmniQL filtering |
| ORDER BY | ‚úÖ | Via OmniQL |
| LIMIT / OFFSET | ‚úÖ | Via OmniQL |
| BEGIN / COMMIT | ‚úÖ | MULTI / EXEC |
| ROLLBACK | ‚úÖ | DISCARD |
| CREATE USER | ‚úÖ | ACL SETUSER |
| GRANT / REVOKE | ‚úÖ | ACL SETUSER |

## Not Supported

| Feature | Reason |
|---------|--------|
| JOIN | Key-value model has no relations |
| GROUP BY / HAVING | Use aggregations instead |
| Window functions | No SQL semantics |
| SAVEPOINT | Redis has no partial rollback |
| Roles | Redis has users only, not roles |

## Performance Considerations

| Query Type | Performance | When to Use |
|------------|-------------|-------------|
| `WHERE id = X` | ‚ö° Instant | Always preferred |
| `WHERE field = X LIMIT N` | üîÑ Scan + filter | Small datasets, with LIMIT |
| `WHERE field = X` (no limit) | ‚ö†Ô∏è Full scan | Avoid on large datasets |

### Best Practices

1. **Use ID lookups when possible** - Direct key access is instant
2. **Always use LIMIT** - Prevents scanning entire keyspace
3. **Index hot queries in SQL** - For complex filtering, consider PostgreSQL
4. **Use Redis for what it's good at** - Sessions, caching, counters, real-time data

## When to Use Redis with OmniQL

**Good use cases:**
- Session storage
- User profiles / settings
- Caching layer
- Real-time counters
- Simple CRUD by ID
- Aggregations on bounded datasets

**Consider PostgreSQL instead:**
- Complex queries with multiple filters
- Relational data with joins
- Large datasets requiring full scans
- Data requiring GROUP BY

## Next Steps

<CardGroup cols={2}>
  <Card title="PostgreSQL" icon="database" href="/databases/postgresql">
    Full-featured SQL database
  </Card>
  <Card title="Operators" icon="code" href="/reference/operators">
    All supported operators
  </Card>
</CardGroup>